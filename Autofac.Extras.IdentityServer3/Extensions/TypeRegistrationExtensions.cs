using System;
using System.Linq;
using Autofac.Core;
using Autofac.Core.Lifetime;
using Autofac.Extras.IdentityServer3.Core;
using Autofac.Integration.Owin;
using IdentityServer3.Core.Configuration;
using IdentityServer3.Core.Services;
using Microsoft.Owin;
using Owin;

namespace Autofac.Extras.IdentityServer3.Extensions
{
    public static class TypeRegistrationExtensions
    {
        public const string CustomDisposeLifetimescopeKey = "IdServerAutofacIntegrationCore.CustomDisposeLifetimescopeKey";
        public const string CustomDisposeLifetimescopeRegisteredKey = CustomDisposeLifetimescopeKey + "Registered";

        public static Options WithTypeRegistrationHandler(this Options options)
        {
            return options
                .WithRegistrationHandler(
                    context => context.ResolvedType != null,
                    (factory, context) => factory.RegisterAsAutofacResolvable(context.ResolvedType, context: context)
                );
        }

        public static Options ResolvingByCastingToTypedService(this Options options)
        {
            return options.UsingTypeResolution(ResolvingByCastingToTypedService);
        }

        /// <summary>
        /// Casts the provided <see cref="Autofac.Core.Service"/> as a <see cref="Autofac.Core.TypedService"/> and returns the <see cref="Autofac.Core.TypedService.ServiceType"/>.
        /// </summary>
        /// <param name="serviceGrouping"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        private static bool ResolvingByCastingToTypedService(IGrouping<Service, IComponentRegistration> serviceGrouping, out Type type)
        {
            type = null;

            var asTypedService = serviceGrouping.Key as TypedService;
            if (asTypedService == null)
                return false;

            type = asTypedService.ServiceType;
            return type != null;
        }

        /// <summary>
        /// Resolve with autofac, or if autofac doesn't exist in the owin context for whatever reason use the provided instance.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="factory"></param>
        /// <param name="instance"></param>
        public static void RegisterAsAutofacResolvableOrUse<T>(this IdentityServerServiceFactory factory, T instance, RegistrationContext context = null) where T : class
        {
            factory.RegisterAsAutofacResolvable<T>(resolveWithOwinContextFunc:
                owinContext =>
                {
                    var autofac = OwinContextExtensions.GetAutofacLifetimeScope(owinContext);
                    return autofac != null
                        ? autofac.Resolve<T>()
                        : instance;
                },
                context: context);
        }

        public static CustomIdServerRegistration CreateRegistration(Type type, Func<ILifetimeScope, object> resolveWithLifetimeScopeFunc = null, Func<IOwinContext, object> resolveWithOwinContextFunc = null, string name = null, IContainer container = null, RegistrationContext context = null)
        {
            var mode = context?.ConvertMode() ?? RegistrationMode.InstancePerUse; // play it safe with InstancePerUse
            if (mode == RegistrationMode.Singleton)
            {
                return new CustomIdServerRegistration(
                    type,
                    // ReSharper disable once PossibleNullReferenceException
                    context.SingletonLifetimeScope.Resolve(type),
                    name)
                {
                    Mode = RegistrationMode.Singleton
                };
            }

            return new CustomIdServerRegistration(
                type,
                dr => ResolveUsingAutofac(dr, type, resolveWithLifetimeScopeFunc, resolveWithOwinContextFunc, container ?? context?.Container),
                name)
            {
                Mode = mode
            };
        }

        public static Registration<T> CreateRegistration<T>(Func<ILifetimeScope, T> resolveWithLifetimeScopeFunc = null, Func<IOwinContext, T> resolveWithOwinContextFunc = null, string name = null, IContainer container = null, RegistrationContext context = null, bool checkForMiddleware = true) where T : class
        {
            var mode = context?.ConvertMode() ?? RegistrationMode.InstancePerUse; // play it safe with InstancePerUse
            if (mode == RegistrationMode.Singleton)
                // ReSharper disable once PossibleNullReferenceException
                return new Registration<T>(ResolutionExtensions.Resolve<T>((IComponentContext) context.SingletonLifetimeScope), name)
                {
                    Mode = RegistrationMode.Singleton
                };

            return new Registration<T>(
                dr => dr.ResolveUsingAutofac<T>(resolveWithLifetimeScopeFunc, resolveWithOwinContextFunc, container ?? context?.Container, checkForMiddleware))
            {
                Mode = mode
            };
        }

        public static T ResolveUsingAutofac<T>(this IDependencyResolver dr, Func<ILifetimeScope, T> resolveWithAutofacFunc = null, Func<IOwinContext, T> resolveWithOwinContextFunc = null, IContainer container = null, bool checkForMiddleware = true)
        {
            var owinContext = dr.Resolve<IOwinContext>();

            if (resolveWithOwinContextFunc != null)
                return resolveWithOwinContextFunc(owinContext);

            var lifetimeScope = owinContext.GetLifetimeScopeHelper(typeof(T), container, checkForMiddleware);

            var resolved = resolveWithAutofacFunc != null
                ? resolveWithAutofacFunc(lifetimeScope)
                : lifetimeScope.Resolve<T>();
            return resolved;
        }

        public static object ResolveUsingAutofac(this IDependencyResolver dr, Type type, Func<ILifetimeScope, object> resolveWithAutofacFunc = null, Func<IOwinContext, object> resolveWithOwinContextFunc = null, IContainer container = null, bool checkForMiddleware = true)
        {
            var owinContext = dr.Resolve<IOwinContext>();

            if (resolveWithOwinContextFunc != null)
                return resolveWithOwinContextFunc(owinContext);

            var lifetimeScope = owinContext.GetLifetimeScopeHelper(type, container, checkForMiddleware);

            var resolved = resolveWithAutofacFunc != null
                ? resolveWithAutofacFunc(lifetimeScope)
                : lifetimeScope.Resolve(type);
            return resolved;
        }

        public static ILifetimeScope GetLifetimeScopeHelper(this IOwinContext owinContext, Type type, IContainer container, bool checkForMiddleware = true)
        {
            var lifetimeScope = owinContext.GetAutofacLifetimeScope();
            if (lifetimeScope != null)
                return lifetimeScope;

            throw new ApplicationException(
                $"Could not get autofac lifetime scope from owin context when trying to resolve {type}.");
        }

        public static void RegisterAsAutofacResolvable(this IdentityServerServiceFactory factory, Type type, Func<ILifetimeScope, object> resolveWithLifetimeScopeFunc = null, Func<IOwinContext, object> resolveWithOwinContextFunc = null, string name = null, IContainer container = null, RegistrationContext context = null)
        {
            factory.Register(CreateRegistration(type, resolveWithLifetimeScopeFunc, resolveWithOwinContextFunc, name, container, context));
        }

        public static void RegisterAsAutofacResolvable<T>(this IdentityServerServiceFactory factory, Func<ILifetimeScope, T> resolveWithLifetimeScopeFunc = null, Func<IOwinContext, T> resolveWithOwinContextFunc = null, string name = null, IContainer container = null, RegistrationContext context = null) where T : class
        {
            factory.Register(CreateRegistration(resolveWithLifetimeScopeFunc, resolveWithOwinContextFunc, name, container, context));
        }

        public static RegistrationMode ConvertMode(this RegistrationContext context)
        {
            if (context == null)
                return RegistrationMode.InstancePerUse; // play it safe with InstancePerUse

            var lifetimes = context.MatchingAutofacRegistrations.Select(r => ConvertFromLifetime(r.Lifetime, r.Sharing)).ToList();
            if (!lifetimes.Any() || lifetimes.Distinct().Count() > 1)
                return RegistrationMode.InstancePerUse; // play it safe with InstancePerUse

            return lifetimes.First();

            RegistrationMode ConvertFromLifetime(IComponentLifetime lifetime, InstanceSharing sharing)
            {
                var instancePerDependency = lifetime is RootScopeLifetime && sharing == InstanceSharing.None;
                if (instancePerDependency)
                    return RegistrationMode.InstancePerUse;

                var singleInstance = lifetime is RootScopeLifetime && sharing == InstanceSharing.Shared;
                if (singleInstance)
                    return RegistrationMode.Singleton;

                var instancePerLifetimeScope = lifetime is CurrentScopeLifetime && sharing == InstanceSharing.Shared;
                if (instancePerLifetimeScope)
                    return RegistrationMode.InstancePerHttpRequest;

                var asMatchingScopeLifetime = lifetime as MatchingScopeLifetime;
                var instancePerRequest = sharing == InstanceSharing.Shared && asMatchingScopeLifetime?.TagsToMatch.All(ttm => ttm == MatchingScopeLifetimeTags.RequestLifetimeScopeTag) == true;
                if (instancePerRequest)
                    return RegistrationMode.InstancePerHttpRequest;

                return RegistrationMode.InstancePerUse; // play it safe with InstancePerUse
            }
        }

        /// <summary>
        /// This should be registered before <see cref="AutofacAppBuilderExtensions.UseAutofacMiddleware"/>
        /// </summary>
        /// <param name="appBuilder"></param>
        /// <param name="container"></param>
        /// <returns></returns>
        [Obsolete("Make sure app.UseAutofacMiddleware() and/or app.UseAutofacLifetimeScopeInjector() is called before app.UseIdentityServer() and remove the call to this method.")]
        public static IAppBuilder UseIdServerAutofacIntegrationMiddleware(this IAppBuilder appBuilder)
        {
            // no-op TODO - (delete this method on next major version).
            return appBuilder;
        }

        public static Options RegisteringOnlyIdServerTypes(this Options options)
        {
            return options.Excluding(
                context => context?.ResolvedType?.Namespace?.StartsWith(nameof(IdentityServer3)) == false
            );
        }

        /// <summary>
        /// IdentityServer3 creates a fake owin context at startup to resolve IEventService. Use this to get around the fact that we don't have an autofac container yet.
        /// </summary>
        /// <param name="options"></param>
        /// <returns></returns>
        public static Options HackingEventServiceForStartup(this Options options)
        {
            return options.WithRegistrationHandlerFor<IEventService>(
                (factory, context) =>
                {
                    factory.RegisterAsAutofacResolvable<IEventService>(resolveWithOwinContextFunc: owinContext =>
                        {
                            var lifetimeScope = owinContext.GetAutofacLifetimeScope();
                            if (lifetimeScope != null)
                                return lifetimeScope.Resolve<IEventService>();

                            var startupScope = context.Container.BeginLifetimeScope(
                                MatchingScopeLifetimeTags.RequestLifetimeScopeTag,
                                b => b.RegisterInstance(owinContext).As<IOwinContext>()
                            );
                            owinContext.SetAutofacLifetimeScope(startupScope);
                            return startupScope.Resolve<IEventService>();
                        });
                },
                100
            );
        }
    }

    public class CustomIdServerRegistration : Registration<object>
    {
        public CustomIdServerRegistration(Type type, Func<IDependencyResolver, object> factory, string name = null)
        {
            DependencyType = type;
            Factory = factory;
            Type = null; // make sure factory is used

            if (name != null)
                Name = name;
        }

        public CustomIdServerRegistration(Type type, object instance, string name = null)
        {
            DependencyType = type;
            Instance = instance;
            Type = null; // make sure factory is used

            if (name != null)
                Name = name;
        }

        public override Type DependencyType { get; }
    }
}
